package hookbridge

import (
	"errors"
	"os"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/kataras/golog"
)

// Config captures the knobs needed to spin up the future UMH bridge.
type Config struct {
	EnableByDefault bool
	Log             *golog.Logger
}

// Policy represents the enforcement directive for a single process/session.
type Policy struct {
	PID          uint32
	SessionID    uint32
	ConnectionID string
	ForceInput   bool
	ForceCapture bool
	Timestamp    time.Time
}

// Event is emitted every time the native bridge reports telemetry.
type Event struct {
	Kind       string
	PID        uint32
	SessionID  uint32
	Details    map[string]any
	RecordedAt time.Time
}

// TelemetrySink consumes events generated by the native bridge.
type TelemetrySink func(Event)

var (
	initOnce        sync.Once
	initErr         error
	enabled         bool
	nativeActive    bool
	currentConfig   Config
	currentSink     TelemetrySink
	defaultLogger   = golog.Child("[hookbridge]")
	errDisabled     = errors.New("hookbridge: feature disabled")
	errNotSupported = errors.New("hookbridge: only supported on Windows")
)

// Init configures the bridge. On non-Windows builds the method is a no-op.
func Init(cfg Config, sink TelemetrySink) error {
	initOnce.Do(func() {
		currentConfig = cfg
		if cfg.Log != nil {
			defaultLogger = cfg.Log
		}
		enabled = shouldEnable(cfg)
		if !enabled {
			return
		}
		if runtime.GOOS != "windows" {
			initErr = errNotSupported
			enabled = false
			return
		}
		currentSink = sink
		if err := nativeInit(cfg); err == nil {
			nativeActive = true
			defaultLogger.Infof("hookbridge native bridge ready (runtime=%s)", runtime.Version())
		} else if err != errNotSupported {
			defaultLogger.Warnf("hookbridge native init failed: %v", err)
		}
		defaultLogger.Infof("hookbridge initialized (runtime=%s)", runtime.Version())
	})
	return initErr
}

// Enabled returns true when the bridge is active for the current process.
func Enabled() bool {
	return enabled && initErr == nil
}

// ApplyPolicy forwards enforcement instructions to the native hook engine.
// Today this is a stub that simply logs the request; future revisions will call into UMH.
func ApplyPolicy(p Policy) error {
	if !Enabled() {
		return errDisabled
	}
	if p.Timestamp.IsZero() {
		p.Timestamp = time.Now()
	}
	if nativeActive {
		if err := nativeApply(p); err != nil {
			defaultLogger.Warnf("native apply failed: %v", err)
		} else {
			dispatchEvent(Event{
				Kind:       "policy_native",
				PID:        p.PID,
				SessionID:  p.SessionID,
				Details:    map[string]any{"forceInput": p.ForceInput, "forceCapture": p.ForceCapture},
				RecordedAt: p.Timestamp,
			})
			return nil
		}
	}
	defaultLogger.Debugf("hookbridge stub ApplyPolicy pid=%d session=%d conn=%s input=%t capture=%t",
		p.PID, p.SessionID, p.ConnectionID, p.ForceInput, p.ForceCapture)
	dispatchEvent(Event{
		Kind:       "policy_stub",
		PID:        p.PID,
		SessionID:  p.SessionID,
		Details:    map[string]any{"forceInput": p.ForceInput, "forceCapture": p.ForceCapture},
		RecordedAt: p.Timestamp,
	})
	return nil
}

// ReleasePolicy notifies the native bridge that a session policy is no longer needed.
func ReleasePolicy(connectionID string) error {
	if !Enabled() {
		return errDisabled
	}
	if connectionID == "" {
		return nil
	}
	if nativeActive {
		if err := nativeRelease(connectionID); err != nil {
			defaultLogger.Warnf("native release failed: %v", err)
		} else {
			dispatchEvent(Event{
				Kind:       "policy_release_native",
				Details:    map[string]any{"connection": connectionID},
				RecordedAt: time.Now(),
			})
			return nil
		}
	}
	defaultLogger.Debugf("hookbridge stub ReleasePolicy conn=%s", connectionID)
	dispatchEvent(Event{
		Kind:       "policy_release_stub",
		Details:    map[string]any{"connection": connectionID},
		RecordedAt: time.Now(),
	})
	return nil
}

// Shutdown tears down the bridge. For now it only resets internal state.
func Shutdown() {
	if !enabled {
		return
	}
	if nativeActive {
		nativeShutdown()
		nativeActive = false
	}
	enabled = false
	defaultLogger.Info("hookbridge shutdown (stub)")
}

func dispatchEvent(evt Event) {
	if currentSink != nil {
		currentSink(evt)
	}
}

func shouldEnable(cfg Config) bool {
	if cfg.EnableByDefault {
		return true
	}
	return strings.EqualFold(os.Getenv("SPARK_EXPERIMENTAL_UMH"), "1")
}
